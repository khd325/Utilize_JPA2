# 컬렉션 조회 최적화

---

컬렉션인 일대다 관계를 조회하는 방법

## V1: 엔티티 직접 노출

---

```java
@RestController
@RequiredArgsConstructor
public class OrderApiController {

    private final OrderRepository orderRepository;

    @GetMapping("/api/v1/orders")
    public List<Order> ordersV1(){
        List<Order> all = orderRepository.findAllByString(new OrderSearch());
        for (Order order : all) {
            order.getMember().getName();
            order.getDelivery().getAddress();
            List<OrderItem> orderItems = order.getOrderItems();
            orderItems.stream().forEach(o -> o.getItem().getName());
        }

        return all;
    }
}
```

`orderItem`, `item` 관계를 직접 초기화하여 Hibernate5Module 설정으로 JOSN 으로 설정한다.

`V1`은 엔티티를 직접 노출하기 때문에 좋지 않다.

---

## V2: 엔티티를 DTO로 변환

---

```java
@RestController
@RequiredArgsConstructor
public class OrderApiController {

    private final OrderRepository orderRepository;
    
    @GetMapping("/api/v2/orders")
    public List<OrderDto> ordersV2(){
        List<Order> orders = orderRepository.findAllByString(new OrderSearch());
        List<OrderDto> collect = orders.stream()
                .map(o -> new OrderDto(o))
                .collect(Collectors.toList());
        return collect;
    }


    @Getter //DTO 로 반환할때는 DTO 안에 엔티티가 들어가 있으면 안됨(OrderItem)
    static class OrderDto{

        private Long orderId;
        private String name;
        private LocalDateTime orderDate;
        private OrderStatus orderStatus;
        private Address address;
        private List<OrderItem> orderItems;

        public OrderDto(Order order) {
            orderId = order.getId();
            name = order.getMember().getName();;
            orderDate = order.getOrderDate();
            orderStatus = order.getStatus();
            address = order.getDelivery().getAddress();
            order.getOrderItems().stream().forEach(o -> o.getItem().getName());
            orderItems = order.getOrderItems();
        }
    }
}
```

DTO안에는 엔티티가 들어가 있으면 안된다. 단순히 DTO로 감싸는게 아니라 의존성을 완전히 끊어야 한다. 

**`OrderItem`조차 다 DTO로 변환해야한다.**

```java
@RestController
@RequiredArgsConstructor
public class OrderApiController {

    private final OrderRepository orderRepository;

    @GetMapping("/api/v2/orders")
    public List<OrderDto> ordersV2() {
        List<Order> orders = orderRepository.findAllByString(new OrderSearch());
        List<OrderDto> result = orders.stream()
                .map(o -> new OrderDto(o))
                .collect(Collectors.toList());
        return result;
    }


    @Getter //DTO 로 반환할때는 DTO 안에 엔티티가 들어가 있으면 안됨(OrderItem)
    static class OrderDto{

        private Long orderId;
        private String name;
        private LocalDateTime orderDate;
        private OrderStatus orderStatus;
        private Address address;
        private List<OrderItem> orderItems;

        public OrderDto(Order order) {
            orderId = order.getId();
            name = order.getMember().getName();;
            orderDate = order.getOrderDate();
            orderStatus = order.getStatus();
            address = order.getDelivery().getAddress();
            order.getOrderItems().stream().forEach(o -> o.getItem().getName());
            orderItems = order.getOrderItems();
        }
    }
    @Getter
    static class OrderItemDto {
        private String itemName;
        private int orderPrice;
        private int count;
        public OrderItemDto(OrderItem orderItem) {
            itemName = orderItem.getItem().getName();
            orderPrice = orderItem.getOrderPrice();
            count = orderItem.getCount();
        }
    }
}
```

V2는 지연 로딩으로 너무 많은 SQL이 실행된다.

---

## V3: 엔티티를 DTO로 변환 - 페치 조인 최적화

---

```java

@RestController
@RequiredArgsConstructor
public class OrderApiController {

  private final OrderRepository orderRepository;

  @GetMapping("/api/v3/orders")
  public List<OrderDto> ordersV3() {
    List<Order> orders = orderRepository.findAllWithItem();

    List<OrderDto> result = orders.stream()
            .map(o -> new OrderDto(o))
            .collect(Collectors.toList());

    return result;
  }


  @Getter //DTO 로 반환할때는 DTO 안에 엔티티가 들어가 있으면 안됨(OrderItem)
  static class OrderDto {

    private Long orderId;
    private String name;
    private LocalDateTime orderDate;
    private OrderStatus orderStatus;
    private Address address;
    private List<OrderItemDto> orderItems;

    public OrderDto(Order order) {
      orderId = order.getId();
      name = order.getMember().getName();

      orderDate = order.getOrderDate();
      orderStatus = order.getStatus();
      address = order.getDelivery().getAddress();
      orderItems = order.getOrderItems().stream()
              .map(orderItem -> new OrderItemDto(orderItem))
              .collect(Collectors.toList());
    }
  }

  @Getter
  static class OrderItemDto {
    private String itemName;
    private int orderPrice;
    private int count;

    public OrderItemDto(OrderItem orderItem) {
      itemName = orderItem.getItem().getName();
      orderPrice = orderItem.getOrderPrice();
      count = orderItem.getCount();
    }
  }

    //OrderRepository
    public List<Order> findAllWithItem() {
        return em.createQuery(
                        "select distinct o from Order o" +
                                " join fetch o.member m" +
                                " join fetch o.delivery d" +
                                " join fetch o.orderItems oi" +
                                " join fetch oi.item i", Order.class)
                .getResultList();
    }

}
```

페치 조인을 적용하여 SQL이 1번만 실행된다.

> JPA의 `distinct`는 1대다 조인(order-orderItems)의 결과로 나오는 뻥튀기 된 데이터를 가져와서 같은 엔티티가 조회되면 중복을 걸러주게 된다.

하지만 컬렉션 페치조인을 적용면 `페이징`이 불가능하다. hibernate의 경우엔 경고 로그를 남기고 메모리에서 자체적으로 페이징하기 때문에 매우 위험하다.

> 컬렉션 페치 조인은 1개만 사용할 수 있다. 컬렉션 둘 이상에 페치 조인을 사용하면 안된다.
---

## V3.1: 엔티티를 DTO로 변환 - 페이징과 한계 돌파

+ 컬렉션을 페치 조인하면 페이징이 불가능하다.
  + 컬렉션을 페치 조인하면 일대다 조인이 발생하므로 데이터가 예측할 수 없이 증가.
  + `일대다` -> `일(1)`을 기준으로 페이징 하는 것이 목적인데 데이터는 다(N) 만큼 로우가 생성된다.
    + `order-orderItems`의 경우 orderItems(N)
+ 하이버네이트에서 경고를 남기고 메모리에서 페이징 시도

---

### 한계 돌파 

페이징 + 컬렉션 엔티티를 함께 조회하는 방법

+ `xToOne`관계를 모두 페치조인 한다. `xToOne`관계는 row수를 증가시키지 않기 때문에 피이징 쿼리에 영향을 주지 않는다.
  + `Order` - `Member,Delivery` (`xToOne`) 관계
+ 컬렉션은 지연 로딩으로 조회한다.
+ 지연 로딩 성능 최적화를 위해 `hibernate.default_batch_fetch_size`(글로벌),`@BatchSize`(특정 엔티티)를 적용한다.
  + 옵션을 사용하면 컬렉션이나, 프록시 객체를 한꺼번에 설정한 size만큼 IN 쿼리로 조회한다.

